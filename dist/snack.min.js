var canvas = document.getElementById('snack_canvas'),
	ctx = canvas.getContext('2d'),
	moveInterval = null,
	bricks = {
		width: 20,
		height: 20,
		vy: 5,
		vx: 5,
		newX: 0,
		newY: 0,
		isEaten: !1,
		isShow: !1,
		tmpPositionX: 0,
		tmpPositionY: 0,
		score: 0,
		eatDetection: function() {
			if (this.data[0].x === this.newX && this.data[0].y === this.newY)
				this.data.push({
					x: this.data[this.data.length - 1].x + this.width,
					y: this.data[this.data.length - 1].y + this.height,
					color: 'yellow'
				}),
					(this.isEaten = !0),
					(this.isShow = !1),
					(this.newY = this.newX = 0),
					this.score++;
			else
				for (var b = this.data[0], a = 1; a < this.data.length; a++)
					b.x === this.data[a].x && b.y === this.data[a].y && (alert('game over'), window.location.reload());
		},
		collision: function() {
			if (
				this.data[0].x + this.width > canvas.width ||
				this.data[0].y + this.height > canvas.height ||
				0 > this.data[0].x ||
				0 > this.data[0].y
			)
				alert('game over'), window.location.reload();
		},
		random: function(b) {
			return Math.floor(Math.random() * Math.floor(b));
		},
		generateNewPosition: function() {
			var b = Math.floor(canvas.height / this.height),
				a = this.random(Math.floor(canvas.width / this.width)) + 1;
			b = this.random(b) + 1;
			a = canvas.width - a * this.width;
			b = canvas.height - b * this.height;
			this.isShow
				? ((this.tmpPositionX = a), (this.tmpPositionY = b))
				: (ctx.rect(a, b, this.width, this.height), (this.newX = a), (this.newY = b));
		},
		randomDraw: function() {
			ctx.beginPath();
			this.isShow ? ctx.rect(this.newX, this.newY, this.width, this.height) : this.generateNewPosition();
			ctx.fillStyle = 'yellow';
			ctx.strokeStyle = 'black';
			ctx.stroke();
			ctx.fill();
			ctx.closePath();
		},
		draw: function(b, a, c) {
			b = canvas.width - b;
			a = canvas.height - a;
			ctx.beginPath();
			ctx.rect(b, a, this.width, this.height);
			ctx.fillStyle = c;
			ctx.strokeStyle = 'black';
			ctx.stroke();
			ctx.fill();
			ctx.closePath();
			this.data.push({ x: b, y: a, color: c });
		},
		drawScore: function() {
			ctx.font = '16px Arial';
			ctx.fillStyle = '#0095DD';
			ctx.fillText('Score: ' + this.score, 8, 20);
		},
		drawAll: function() {
			for (var b = 0; b < this.data.length; b++) {
				var a = this.data[b];
				a &&
					(ctx.beginPath(),
					ctx.rect(a.x, a.y, this.width, this.height),
					(ctx.fillStyle = a.color),
					(ctx.strokeStyle = 'black'),
					ctx.stroke(),
					ctx.fill(),
					ctx.closePath());
			}
		},
		data: [],
		changePosition: function(b) {
			for (var a = 0; a < this.data.length; a++) {
				v = this.data[a];
				if (0 == a)
					switch (b) {
						case 'up':
							this.data[a] = { x: v.x, y: v.y - this.height, color: v.color };
							break;
						case 'down':
							this.data[a] = { x: v.x, y: v.y + this.height, color: v.color };
							break;
						case 'left':
							this.data[a] = { x: v.x - this.width, y: v.y, color: v.color };
							break;
						case 'right':
							this.data[a] = { x: v.x + this.width, y: v.y, color: v.color };
					}
				else this.data[a] = { x: prevX, y: prevY, color: v.color };
				prevX = v.x;
				prevY = v.y;
				0 === a && (this.eatDetection(), this.collision());
			}
		},
		move: function() {
			_this = this;
			keyboard.isUpPress
				? _this.changePosition('up')
				: keyboard.isLeftPress
					? _this.changePosition('left')
					: keyboard.isRightPress
						? _this.changePosition('right')
						: keyboard.isDownPress && _this.changePosition('down');
		}
	},
	keyboard = {
		isUpPress: !1,
		isDownPress: !1,
		isLeftPress: !1,
		isRightPress: !1,
		keyUpHandler: function(b) {},
		keyDownHandler: function(b) {
			keyboard.triggerPress(b.keyCode);
			bricks.move();
		},
		togglePress: function(b) {
			if (2 <= bricks.data.length) {
				var a = bricks.data[0].x - bricks.data[1].x,
					c = bricks.data[0].y - bricks.data[1].y;
				switch (b) {
					case 'up':
						if (0 < a || 0 > a || 0 > c)
							(clearInterval = null),
								(this.isUpPress = !this.isUpPress),
								(this.isRightPress = this.isLeftPress = this.isDownPress = !1);
						break;
					case 'down':
						if (0 < a || 0 > a || 0 < c)
							(clearInterval = null),
								(this.isDownPress = !this.isDownPress),
								(this.isRightPress = this.isLeftPress = this.isUpPress = !1);
						break;
					case 'left':
						if (0 > a || 0 > c || 0 < c)
							(clearInterval = null),
								(this.isLeftPress = !this.isLeftPress),
								(this.isRightPress = this.isDownPress = this.isUpPress = !1);
						break;
					case 'right':
						if (0 < a || 0 > c || 0 < c)
							(clearInterval = null),
								(this.isRightPress = !this.isRightPress),
								(this.isLeftPress = this.isDownPress = this.isUpPress = !1);
				}
			} else
				switch (b) {
					case 'up':
						clearInterval = null;
						this.isUpPress = !this.isUpPress;
						this.isRightPress = this.isLeftPress = this.isDownPress = !1;
						break;
					case 'down':
						clearInterval = null;
						this.isDownPress = !this.isDownPress;
						this.isRightPress = this.isLeftPress = this.isUpPress = !1;
						break;
					case 'left':
						clearInterval = null;
						this.isLeftPress = !this.isLeftPress;
						this.isRightPress = this.isDownPress = this.isUpPress = !1;
						break;
					case 'right':
						(clearInterval = null),
							(this.isRightPress = !this.isRightPress),
							(this.isLeftPress = this.isDownPress = this.isUpPress = !1);
				}
		},
		triggerPress: function(b) {
			switch (b) {
				case 37:
					this.togglePress('left');
					break;
				case 38:
					this.togglePress('up');
					break;
				case 39:
					this.togglePress('right');
					break;
				case 40:
					this.togglePress('down');
			}
		}
	};
document.addEventListener('keydown', keyboard.keyDownHandler, !1);
document.addEventListener('keyup', keyboard.keyUpHandler, !1);
function draw() {
	ctx.clearRect(0, 0, canvas.width, canvas.height);
	bricks.drawAll();
	bricks.drawScore();
	bricks.isShow && bricks.randomDraw();
	bricks.isShow || (bricks.randomDraw(), (bricks.isShow = !0));
	moveInterval ||
		(moveInterval = setInterval(function() {
			bricks.move();
		}, 500));
	requestAnimationFrame(draw);
}
draw();
bricks.generateNewPosition();
var positionX = bricks.tmpPositionX,
	positionY = bricks.tmpPositionY;
positionX === bricks.newX &&
	positionY === bricks.newY &&
	((positionX = positionX === canvas.width ? positionX - bricks.width : positionX + bricks.width),
	(positionY = positionY === canvas.height ? positionY - bricks.height : positionY + bricks.height));
bricks.draw(canvas.width - positionX, canvas.height - positionY, 'blue');
